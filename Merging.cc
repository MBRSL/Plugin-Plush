#include "OpenMesh_Boost_Wrapper.hh"
#include "PlushPatternGenerator.hh"
#include "WeightFunctor.hh"
#include "FilteredTriMesh.hh"
#include "DLX.hh"

#include <queue>
#include <unordered_set>
/*
 @brief Merge two adjacent (seam_segment_idx is the intersection boundary) patches.
 @param seam_segment_idx
     The idx of seam segment which is used to merged these two patch. This is the edge# of subMesh_graph.
 @param subMesh_boundary_graph
     The relationship graph of boundary. Used to calculate seam score.
 @param weightFunctor
     Used to calculate seam score.
 */

Patch_boundary PlushPatternGenerator::merge_patch(Patch_boundary &patch1,
                                                  Patch_boundary &patch2,
                                                  int seam_segment_idx,
                                                  SubMesh_boundary_graph &subMesh_boundary_graph,
                                                  WeightFunctor &weightFunctor) {
    Patch_boundary merged_patch(patch1.boundary_seam_idx.size(), patch1.merged_subMesh_idx.size());
    
    merged_patch.merged_seam_idx = patch1.merged_seam_idx | patch2.merged_seam_idx;
    merged_patch.merged_seam_idx[seam_segment_idx] = true;
    merged_patch.n_merged_seams = patch1.n_merged_seams + patch2.n_merged_seams + 1;
    
    merged_patch.boundary_seam_idx = patch1.boundary_seam_idx | patch2.boundary_seam_idx;
    merged_patch.boundary_seam_idx -= merged_patch.merged_seam_idx;
    
    merged_patch.merged_subMesh_idx = patch1.merged_subMesh_idx | patch2.merged_subMesh_idx;

    // Calculate seam score for all boundary seam segments
    SubMesh_boundary_graph::edge_iterator e_it, e_ite;
    for (boost::tie(e_it, e_ite) = boost::edges(subMesh_boundary_graph); e_it != e_ite; e_it++) {
        int idx = boost::get(boost::edge_index, subMesh_boundary_graph, *e_it);
        if (merged_patch.boundary_seam_idx[idx]) {
            auto seam_segment = boost::get(boost::edge_owner, subMesh_boundary_graph, *e_it);
            merged_patch.seam_score += weightFunctor.operator()(seam_segment);
        }
    }
    return merged_patch;
}

/**
 @brief Construct sets of patches from sub-meshes separated by seams.
 Here we defined the term "sub-mesh" as the smallest mesh separated by seams and
 "patch" is generated by merging one adjacent sub-meshes.
 The process is illustrated as following:
 1. Treat each sub-mesh as a patch consist only one sub-mesh. These are the level 0 patches.
 2. For each level 0 patch, find its neigboring sub-mesh
    and merge them if the distortion is smaller than threshold.
    The merged patches are the level 1 patches.
 3. Repeat step 2 for next level until no patches in this level. i.e., no patches can be merged.
 @param threshold The distortion (area change of faces) threshold used for testing whether two patches can be merged
 @param maximum_patches_per_level The maximum number of patches in each level. Because this process is computational intense, this number can be used for early termination.
 */
void PlushPatternGenerator::construct_subsets(double threshold, unsigned long maximum_patches_per_level) {
    isJobCanceled = false;
    
    std::set<EdgeHandle> &seams = m_mesh->property(seams_handle);
    
    m_mesh->property(subMeshes_handle) = get_subMeshes_with_boundary(seams);
    SubMesh_graph &subMesh_graph = m_mesh->property(subMeshes_handle);
    // Record the best layout given Patch_idx
    std::map<FilteredTriMesh::Patch_idx, Patch_boundary> optimal_patches;

    // This stores which patch has been calculated
    std::set<FilteredTriMesh::Seam_idx> is_patch_calculated;
    
    // The merged result of this iteration, will be used as base patch in the next iteration
    std::map<FilteredTriMesh::Patch_idx, Patch_boundary> base_patches;

    // Used to calculate seam score
    VertexHandle dummy;
    WeightFunctor weightFunctor(m_mesh, dummy, NULL,
                                m_distanceCoefficient,
                                m_textureCoefficient,
                                m_curvatureCoefficient,
                                m_skeletonCoefficient,
                                m_pathCoefficient
                                );

    // Create a boundary graph of first level so that we don't need to create Patch_boundary for basic patch everytime
    int progress_counter = 0;
    SubMesh_boundary_graph subMesh_boundary_graph;
    SubMesh_graph::vertex_iterator v_it, v_ite;
    for (boost::tie(v_it, v_ite) = boost::vertices(subMesh_graph); v_it != v_ite; v_it++) {
        FilteredTriMesh &subMesh = boost::get(boost::vertex_owner, subMesh_graph, *v_it);

        Patch_boundary subMesh_boundary(boost::num_edges(subMesh_graph), boost::num_vertices(subMesh_graph));
        
        subMesh_boundary.merged_subMesh_idx[*v_it] = true;

        SubMesh_graph::out_edge_iterator e_it, e_ite;
        for (boost::tie(e_it, e_ite) = boost::out_edges(*v_it, subMesh_graph); e_it != e_ite; e_it++) {
            int seam_segment_idx = boost::get(boost::edge_index, subMesh_graph, *e_it);
            subMesh_boundary.boundary_seam_idx[seam_segment_idx] = true;
            
            auto seam_segment = boost::get(boost::edge_owner, subMesh_graph, *e_it);
            subMesh_boundary.seam_score += weightFunctor(seam_segment);
        }

        for (VertexHandle v : subMesh.vertices()) {
            double curvature = m_mesh->property(gaussianCurvatureHandle, v);
            if (!subMesh.is_boundary(v) && abs(curvature) > threshold) {
                subMesh_boundary.developable = false;
                break;
            }
        }

        boost::add_vertex(subMesh_boundary, subMesh_boundary_graph);
        
        optimal_patches.emplace(subMesh_boundary.merged_subMesh_idx, subMesh_boundary);
        if (subMesh_boundary.developable) {
            base_patches.emplace(subMesh_boundary.merged_subMesh_idx, subMesh_boundary);
        }
    }
    SubMesh_graph::edge_iterator e_it, e_ite;
    for (boost::tie(e_it, e_ite) = boost::edges(subMesh_graph); e_it != e_ite; e_it++) {
        SubMesh_graph::vertex_descriptor source = boost::source(*e_it, subMesh_graph);
        SubMesh_graph::vertex_descriptor target = boost::target(*e_it, subMesh_graph);
        int idx = boost::get(boost::edge_index, subMesh_graph, *e_it);
        auto &seam_segment = boost::get(boost::edge_owner, subMesh_graph, *e_it);
        
        SubMesh_boundary_graph::edge_descriptor e = boost::add_edge(source, target, subMesh_boundary_graph).first;
        boost::put(boost::edge_index, subMesh_boundary_graph, e, idx);
        boost::put(boost::edge_owner, subMesh_boundary_graph, e, seam_segment);
    }
    
    // Construct larger patches by merging smaller patches of previous level
    int level;
    // Unfortunately this process is computationaly intense. So we use a maximum number for early termination
    for (level = 1; base_patches.size() < maximum_patches_per_level && !base_patches.empty(); level++) {
        printf("Level %d: %lu patches\n", level, base_patches.size());

        std::map<FilteredTriMesh::Patch_idx, Patch_boundary> next_base_patches;
        // For every patch, test if it can be merged with its neighbors
        progress_counter = 0;
        for (auto &pair : base_patches) {
            Patch_boundary &patch_boundary = pair.second;
            if (isJobCanceled) {
                emit log(LOGINFO, "Subset calculation canceled.");
                return;
            }
            
            // For each sub-mesh in this patch, find its neigboring sub-mesh for merging
            for (SubMesh_boundary_graph::vertex_descriptor v1 = patch_boundary.merged_subMesh_idx.find_first();
                 v1 != patch_boundary.merged_subMesh_idx.npos;
                 v1 = patch_boundary.merged_subMesh_idx.find_next(v1)) {
                SubMesh_boundary_graph::out_edge_iterator e_it, e_ite;
                for (boost::tie(e_it, e_ite) = boost::out_edges(v1, subMesh_boundary_graph); e_it != e_ite; e_it++) {
                    int seam_segment_idx = boost::get(boost::edge_index, subMesh_graph, *e_it);
                    
                    // Only deal with segment that are not merged yet
                    if (patch_boundary.merged_seam_idx[seam_segment_idx]) {
                        continue;
                    }
                    
                    // Ignore non-developable sub-meshes
                    SubMesh_boundary_graph::vertex_descriptor v2 = boost::target(*e_it, subMesh_boundary_graph);
                    Patch_boundary &neighboring_subMesh_boundary = boost::get(boost::vertex_owner, subMesh_boundary_graph, v2);
                    if (!neighboring_subMesh_boundary.developable) {
                        continue;
                    }
                
                    // Test if it's already calculated
                    boost::dynamic_bitset<> merged_seam_idx = patch_boundary.merged_seam_idx;
                    merged_seam_idx[seam_segment_idx] = true;
                    if (is_patch_calculated.find(merged_seam_idx) != is_patch_calculated.end()) {
                        continue;
                    }
                    is_patch_calculated.insert(merged_seam_idx);

                    // Create a merged sub-mesh
                    std::vector<HalfedgeHandle> seam_segment = boost::get(boost::edge_owner, subMesh_boundary_graph, *e_it);
                    Patch_boundary merged_boundary = merge_patch(patch_boundary,
                                                                 neighboring_subMesh_boundary,
                                                                 seam_segment_idx,
                                                                 subMesh_boundary_graph,
                                                                 weightFunctor);

                    // check the guassian curvature of the segment to be merged
                    // if all curvature < threshold, then this segment can be merged
                    // note that boundary vertices do not need to have 0 curvature
                    for (size_t i = 0; i <= seam_segment.size(); i++) {
                        VertexHandle v;
                        if (i == 0) {
                            HalfedgeHandle heh = seam_segment.front();
                            v = m_mesh->from_vertex_handle(heh);
                        } else if (i == seam_segment.size()){
                            HalfedgeHandle heh = seam_segment.back();
                            v = m_mesh->to_vertex_handle(heh);
                        } else {
                            HalfedgeHandle heh = seam_segment.at(i);
                            v = m_mesh->from_vertex_handle(heh);
                        }
                        
                        // For end points of this segment, we have to determine whether they are boundary points or not
                        bool is_boundary = false;
                        if (i == 0 || i == seam_segment.size()) {
                            // We can check the end points of neighboring seam segments
                            // If the end points of this segment is the same of the one of other segments, it's boundary
                            SubMesh_boundary_graph::edge_iterator e_it2, e_ite2;
                            for (boost::tie(e_it2, e_ite2) = boost::edges(subMesh_boundary_graph); e_it2 != e_ite2; e_it2++) {
                                int idx = boost::get(boost::edge_index, subMesh_boundary_graph, *e_it2);
                                if (!merged_boundary.boundary_seam_idx[idx]) {
                                    continue;
                                }

                                auto neighboring_seam_segment = boost::get(boost::edge_owner, subMesh_boundary_graph, *e_it2);
                                if (m_mesh->from_vertex_handle(neighboring_seam_segment.front()) == v ||
                                    m_mesh->to_vertex_handle(neighboring_seam_segment.back()) == v) {
                                    is_boundary = true;
                                    break;
                                }
                            }
                        }
                        
                        double gaussian_curvature = m_mesh->property(gaussianCurvatureHandle, v);
                        if (!is_boundary && abs(gaussian_curvature) > threshold) {
                            merged_boundary.developable = false;
                            break;
                        }
                    }
                    
                    if (!merged_boundary.developable) {
                        continue;
                    }
                    
                    auto found_prev_patch = optimal_patches.find(merged_boundary.merged_subMesh_idx);
                    if (found_prev_patch != optimal_patches.end()) {
                        double prev_seam_score = found_prev_patch->second.seam_score;
                        if (prev_seam_score == -1 || merged_boundary.seam_score < prev_seam_score) {
                            found_prev_patch->second = merged_boundary;
                            
                            // Replace record in next_base_patches to prevent from calculating more candidate patches
                            auto found_next_base_patch = next_base_patches.find(merged_boundary.merged_subMesh_idx);
                            if (found_next_base_patch != next_base_patches.end()) {
                                found_next_base_patch->second = merged_boundary;
                            } else {
                                next_base_patches.emplace(merged_boundary.merged_subMesh_idx, merged_boundary);
                            }
                        }
                    } else {
                        optimal_patches.emplace(merged_boundary.merged_subMesh_idx, merged_boundary);
                        next_base_patches.emplace(merged_boundary.merged_subMesh_idx, merged_boundary);
                    }

                }
            }
            progress_counter++;
            emit setJobState((double)progress_counter/base_patches.size() * 100);
        }
        
        base_patches = std::move(next_base_patches);
        next_base_patches.clear();
    }
    // Add result to property, sorting them from large to small
    m_mesh->property(subsets_handle).clear();
    for (int l = level; l >= 0; l--) {
        for (auto &pair : optimal_patches) {
            Patch_boundary patch = pair.second;
            if ((int)patch.n_merged_seams == l) {
                m_mesh->property(subsets_handle).push_back(patch);
            }
        }
    }
}

void PlushPatternGenerator::calc_union() {
    int num_subMeshes = m_mesh->property(subsets_handle).front().merged_subMesh_idx.size();
    DLX dlx(m_mesh->property(subsets_handle), num_subMeshes);
    connect(&dlx, SIGNAL(setJobState(int)), this, SIGNAL(setJobState(int)));
    
    dlx.search(0);
    
    m_mesh->property(merged_patches_idx_handle) = std::move(dlx.get_results());
}

/**
 This function returns the patches(merged sub-meshes) and a lists containing ids of how to union them
 @param patches The merged sub-meshes
 @param union_lists Lists (may be more than one) of ids of patches. The union of ids in a list forms a complete mesh.
 @return <#retval#>
 @retval <#meaning#>
 */
//void PlushPatternGenerator::get_union(const std::vector<FilteredTriMesh> *&patches, std::vector< std::vector<int> > &union_lists) {
void PlushPatternGenerator::get_union(std::vector<Patch_boundary> *&patches, std::vector< std::vector<int> > &union_lists) {
    patches = &m_mesh->property(subsets_handle);
    union_lists = m_mesh->property(merged_patches_idx_handle);
}

bool PlushPatternGenerator::save_patches() {
    ofstream out((m_meshName + ".subset").toLocal8Bit().data(), ios::out | ios::binary);
    long long num_patches = m_mesh->property(subsets_handle).size();
    out.write(reinterpret_cast<const char *>(&num_patches), sizeof(num_patches));
    
    for (Patch_boundary &patch : m_mesh->property(subsets_handle)) {
        boost::archive::text_oarchive oa(out);
        oa << patch;
    }
    
    out.close();
    return true;
}

bool PlushPatternGenerator::load_patches() {
    ifstream in((m_meshName + ".subset").toLocal8Bit().data(), ios::in | ios::binary);
    long long num_patches;
    in.read(reinterpret_cast<char *>(&num_patches), sizeof(num_patches));
    
    for (int i = 0; i < num_patches; i++) {
        boost::archive::text_iarchive ia(in);
        Patch_boundary patch(ia);
        m_mesh->property(subsets_handle).push_back(patch);
    }
    in.close();
    return true;
}

void PlushPatternGenerator::optimize_patches(double threshold, bool step) {
    isJobCanceled = false;
    
    std::map< std::set<HalfedgeHandle>, double > &boundary_distortion = m_mesh->property(joint_boundary_distortion_handle);
    std::map< std::set<HalfedgeHandle>, double > &boundary_area = m_mesh->property(joint_boundary_area_handle);
    
    VertexHandle dummy;
    WeightFunctor weightFunctor(m_mesh, dummy, NULL,
                                m_distanceCoefficient,
                                m_textureCoefficient,
                                m_curvatureCoefficient,
                                m_skeletonCoefficient,
                                m_pathCoefficient
                                );
    
    std::set<EdgeHandle> &seams = m_mesh->property(seams_handle);
    
    std::set<VertexHandle> &intersection_points = m_mesh->property(intersection_points_handle);
    if (intersection_points.empty()) {
        intersection_points = get_intersection_points(seams);
    }
    
    bool cant_be_merged_anymore = false;
    while (!cant_be_merged_anymore) {
        cant_be_merged_anymore = true;
        
        std::vector< std::vector<HalfedgeHandle> > heh_segments;
//        heh_segments = get_halfedge_segments_from_seams(seams);
        heh_segments = get_halfedge_segments_from_seams(intersection_points, seams);
        
        // Sort from high to low
        typedef std::pair<std::vector<HalfedgeHandle>, double> Segment_pair;
        auto comparator = [](Segment_pair p1, Segment_pair p2) ->bool {
            return p1.second < p2.second;
        };
        std::priority_queue<Segment_pair, std::vector<Segment_pair>, decltype(comparator)> sorted_segments(comparator);
        for (auto heh_segment : heh_segments) {
            bool different_texture = false;
            for (HalfedgeHandle heh : heh_segment) {
                
                // If this segment contains different texture, it should not be merge
                if (is_different_texture(m_mesh, heh)) {
                    different_texture = true;
                    break;
                }
            }
            if (!different_texture) {
                double weight = weightFunctor(heh_segment);
                sorted_segments.push(std::make_pair(heh_segment, weight));
            }
        }
        
        int iterations = 0;
        int num_original_segments = sorted_segments.size();
        while (!sorted_segments.empty()) {
            if (isJobCanceled) {
                emit log(LOGINFO, "Merging canceled.");
                return;
            }
            
            Segment_pair pair = sorted_segments.top();
            std::vector<HalfedgeHandle> segment = pair.first;
            sorted_segments.pop();
            
            bool can_be_merge = true;
//            double A = 0, L2_M = 0;
            double max_area_diff[3];
            double sum_area[3];
            std::set<HalfedgeHandle> boundaries[3];
            get_adjacent_boundary(*segment.begin(), seams, boundaries[0]);
            get_adjacent_boundary(m_mesh->opposite_halfedge_handle(*segment.begin()), seams, boundaries[1]);
            
            // The third one is the joint boundary of the first two.
            get_joint_boundary(boundaries[0], boundaries[1], segment, boundaries[2], seams);

            for (int i = 0; i < 3; i++) {
                if (boundary_distortion.find(boundaries[i]) == boundary_distortion.end()) {
                    FilteredTriMesh submesh = get_subMesh_with_boundary(m_mesh->face_handle(*boundaries[i].begin()), boundaries[i]);

                    std::map<HalfedgeHandle, OpenMesh::Vec3d> boundaryPosition;
                    calcLPFB(submesh, boundaryPosition);
                    calcInteriorPoints(submesh, boundaryPosition);
                    calcDistortion(submesh);
                
                    max_area_diff[i] = std::numeric_limits<double>::min();
                    sum_area[i] = 0;
                    for (FaceHandle f : submesh.faces()) {
                        sum_area[i] += submesh.calc_sector_area(submesh.halfedge_handle(f));
                        
                        double distortion = m_mesh->property(distortionFHandle, f);
                        max_area_diff[i] = max(max_area_diff[i], abs(distortion));
                    }
                    boundary_distortion[boundaries[i]] = max_area_diff[i];
                    boundary_area[boundaries[i]] = sum_area[i];
                } else {
                    max_area_diff[i] = boundary_distortion[boundaries[i]];
                    sum_area[i] = boundary_area[boundaries[i]];
                }
            }
            //                    double sum_area_3D = 0;
            //                    double sum_area_2D = 0;
            //                    double sum_L2_Ti_mul_A_prime_Ti = 0;
            //                    auto inverse_mapping = getInverseMappingHandle(&merged_mesh);
            //                    for (FaceHandle f : merged_mesh.faces()) {
            //                        FaceHandle original_f = get_original_handle(&merged_mesh, f);
            //                        double area_3D = m_mesh->calc_sector_area(m_mesh->halfedge_handle(original_f));
            //                        sum_area_3D += area_3D;
            //                        double area_2D = merged_mesh.calc_sector_area(merged_mesh.halfedge_handle(f));
            //                        sum_area_2D += area_2D;
            //
            //                        // Texture stretch from
            //                        // P.V. Sander, J. Snyder, S.J. Gortler, and H. Hoppe,
            //                        // “Texture Mapping Progressive Meshes,” Proc. ACM SIGGRAPH ’01, pp. 409-416, 2001
            //                        TriMesh::ConstFaceVertexIter cfv_it = merged_mesh.cfv_iter(f);
            //                        TriMesh::Point p1 = merged_mesh.point(*cfv_it);
            //                        TriMesh::Point q1 = m_mesh->point(merged_mesh.property(inverse_mapping, *cfv_it++));
            //                        TriMesh::Point p2 = merged_mesh.point(*cfv_it);
            //                        TriMesh::Point q2 = m_mesh->point(merged_mesh.property(inverse_mapping, *cfv_it++));
            //                        TriMesh::Point p3 = merged_mesh.point(*cfv_it);
            //                        TriMesh::Point q3 = m_mesh->point(merged_mesh.property(inverse_mapping, *cfv_it++));
            //
            //                        OpenMesh::Vec3d Ss = (q1 * (p2[1] - p3[1]) + q2 * (p3[1] - p1[1]) + q3 * (p1[1] - p2[1]))/ (2 * area_2D);
            //                        OpenMesh::Vec3d St = (q1 * (p3[0] - p2[0]) + q2 * (p1[0] - p3[0]) + q3 * (p2[0] - p1[0]))/ (2 * area_2D);
            //                        double a = Ss | Ss;
            //                        double c = St | St;
            //                        double L2_Ti = sqrt((a + c)/2);
            //                        sum_L2_Ti_mul_A_prime_Ti += L2_Ti * L2_Ti * area_3D;
            //                    }
            //                    L2_M = sqrt(sum_L2_Ti_mul_A_prime_Ti/sum_area_3D);
            //                    A = abs(sum_area_2D - sum_area_3D)/sum_area_3D;
            
            // Now we should have the distortion of these boundary
            // The joint boundary is not developable if it satisfied all of the followings:
            // 1. max_area_diff greater than threshold
            // 2. The distortion doesn't increase too much (This usually happens when merging large patch with tiny patch)
            if (max_area_diff[2] > threshold) {
                if (min(sum_area[0], sum_area[1])/max(sum_area[0], sum_area[1]) < 0.01) {
                    can_be_merge = true;
                } else {
                    can_be_merge = false;
                }
            }
            
            iterations++;
            emit setJobState((double)iterations/num_original_segments * 100);
            
            if (!can_be_merge) {
                // Restore seams if not developable
                for (HalfedgeHandle heh : segment) {
                    seams.insert(m_mesh->edge_handle(heh));
                }
            } else {
                // visualization
                for (HalfedgeHandle heh : prevBoundary) {
                    EdgeHandle eh = m_mesh->edge_handle(heh);
                    m_mesh->set_color(eh, TriMesh::Color(1,1,1,0));
                    m_mesh->status(eh).set_selected(true);
//                    m_mesh->status(heh).set_selected(false);
                }
                for (HalfedgeHandle heh : prevSegment) {
                    EdgeHandle eh = m_mesh->edge_handle(heh);
                    m_mesh->set_color(eh, TriMesh::Color(1,1,1,0));
                    m_mesh->status(eh).set_selected(false);
                }

                prevBoundary.clear();
                if (boundaries[2].empty()) {
                    emit log(LOGERR, "No boundary is found in submesh[2]");
                    return;
                }
                for (HalfedgeHandle heh : boundaries[2]) {
                    EdgeHandle eh = m_mesh->edge_handle(heh);
                    m_mesh->set_color(eh, TriMesh::Color(0,1,0,1));
                    m_mesh->status(eh).set_selected(false);
//                    m_mesh->status(heh).set_selected(true);
                }
                prevBoundary = boundaries[2];
                
                for (HalfedgeHandle heh : segment) {
                    EdgeHandle eh = m_mesh->edge_handle(heh);
                    seams.erase(eh);
                    m_mesh->set_color(eh, TriMesh::Color(0,0,1,1));
                    m_mesh->status(eh).set_selected(false);
                }
                prevSegment = segment;
                
                cant_be_merged_anymore = false;
                
                emit updateView();
                
                if (step) {
                    return;
                } else {
                    break;
                }
            }
        }
    }
    
    // Assign color for segment
    std::vector< std::vector<HalfedgeHandle> > heh_segments = get_halfedge_segments_from_seams(seams);
    
    int count = 0;
    for (auto heh_segment : heh_segments) {
        for (HalfedgeHandle heh : heh_segment) {
            EdgeHandle eh = m_mesh->edge_handle(heh);
            m_mesh->property(segment_no_handle, eh) = count;
        }
        count = (count+20) % 255;
    }
}
